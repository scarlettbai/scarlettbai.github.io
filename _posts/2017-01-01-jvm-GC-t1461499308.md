---
layout: post
title: [转]JVM GC算法
description: "【GC】JVM GC算法."
tags: [算法]
image:
  background: triangular.png
---



> 原文作者：http://www.cnblogs.com/zuoxiaolong/      侵删

**GC策略解决了哪些问题？**

既然是要进行自动GC，那必然会有相应的策略，而这些策略解决了哪些问题呢，粗略的来说，主要有以下几点。

1、哪些对象可以被回收。

2、何时回收这些对象。

3、采用什么样的方式回收。

**GC策略采用的何种算法**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有关上面所提到的三个问题，其实最主要的一个问题就是第一个，也就是哪些对象才是可以回收的,有一种比较简单直观的办法，它的效率较高，被称作引用计数算法，其原理是：此对象有一个引用，则+1；删除一个引用，则-1。只用收集计数为0的对象。缺点是： （1）无法处理循环引用的问题。如：对象A和B分别有字段b、a，令A.b=B和B.a=A，除此之外这2个对象再无任何引用，那实际上这2个对象已经不可能再被访问，但是引用计数算法却无法回收他们。（2）引用计数的方法需要编译器的配合，编译器需要为此对象生成额外的代码。如赋值函数将此对象赋值给一个引用时，需要增加此对象的引用计数。还有就是，当一个引用变量的生命周期结束时，需要更新此对象的引用计数器。引用计数的方法由于存在显著的缺点，实际上并未被JVM所使用。想象一下，假设JVM采用这种GC策略，那么程序猿在编写的程序的时候，下面这样的代码就不要指望再出现了。

```
public class Object {

    Object field = null;
    
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            public void run() {
                Object objectA = new Object();
                Object objectB = new Object();//1
                objectA.field = objectB;
                objectB.field = objectA;//2
                //to do something
                objectA = null;
                objectB = null;//3
            }
        });
        thread.start();
        while (true);
    }
    
}
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这段代码看起来有点刻意为之，但其实在实际编程过程当中，是经常出现的，比如两个一对一关系的数据库对象，各自保持着对方的引用,最后一个无限循环只是为了保持JVM不退出，没什么实际意义。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于我们现在使用的GC来说，当thread线程运行结束后，会将objectA和objectB全部作为待回收的对象,而如果我们的GC采用上面所说的引用计数算法，则这两个对象永远不会被回收，即便我们在使用后显示的将对象归为空值也毫无作用。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里LZ大致解释一下，在代码中LZ标注了1、2、3三个数字，当第1个地方的语句执行完以后，两个对象的引用计数全部为1。当第2个地方的语句执行完以后，两个对象的引用计数就全部变成了2。当第3个地方的语句执行完以后，也就是将二者全部归为空值以后，二者的引用计数仍然为1。根据引用计数算法的回收规则，引用计数没有归0的时候是不会被回收的。

**根搜索算法**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于引用计数算法的缺陷，所以JVM一般会采用一种新的算法，叫做根搜索算法。它的处理方式就是，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。
![](/postimages/0943425N6-0.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就拿上图来说，ObjectD和ObjectE是互相关联的，但是由于GC roots到这两个对象不可达，所以最终D和E还是会被当做GC的对象，上图若是采用引用计数法，则A-E五个对象都不会被回收，说到GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：

**1、虚拟机栈中的引用的对象。**

**2、方法区中的类静态属性引用的对象。**

**3、方法区中的常量引用的对象。**

**4、本地方法栈中JNI的引用的对象。**

第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根搜索算法解决的是垃圾搜集的基本问题，也就是上面提到的第一个问题，也是最关键的问题，就是哪些对象可以被回收，**不过垃圾收集显然还需要解决后两个问题，什么时候回收以及如何回收**，在根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，**分别是标记-清除算法、复制算法、标记-整理算法**，这三种算法都扩充了根搜索算法，不过它们理解起来还是非常好理解的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们回想一下上一章提到的根搜索算法，它可以解决我们应该回收哪些对象的问题，但是它显然还不能承担垃圾搜集的重任，因为我们在程序（程序也就是指我们运行在JVM上的JAVA程序）运行期间如果想进行垃圾回收，就必须让GC线程与程序当中的线程互相配合，才能在不影响程序运行的前提下，顺利的将垃圾进行回收。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了达到这个目的，**标记/清除算法**就应运而生了，它的做法是当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。

（1）标记：标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。

（2）清除：清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这两个步骤并不是特别复杂，也很容易理解。LZ用通俗的话解释一下标记/清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，**GC线程就会被触发并将程序暂停，随后将依旧存活的对象标记一遍，最终再将堆中所有没被标记的对象全部清除掉，接下来便让程序恢复运行**。

下面LZ给各位制作了一组描述上面过程的图片，结合着图片，我们来直观的看下这一过程，首先是第一张图。
![](/postimages/09462AW8-0.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图代表的是程序运行期间所有对象的状态，它们的标志位全部是0（也就是未标记，以下默认0就是未标记，1为已标记），假设这会儿有效内存空间耗尽了，JVM将会停止应用程序的运行并开启GC线程，然后开始进行标记工作，按照根搜索算法，标记完以后，对象的状态如下图。
![](/postimages/09462A344-1.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，按照根搜索算法，所有从root对象可达的对象就被标记为了存活的对象，此时已经完成了第一阶段标记。接下来，就要执行第二阶段清除了，那么清除完以后，剩下的对象以及对象的状态如下图所示。
![](/postimages/09462B628-2.jpg)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，没有被标记的对象将会回收清除掉，而被标记的对象将会留下，并且会将标记位重新归0。接下来就不用说了，唤醒停止的程序线程，让程序继续运行即可，其实这一过程并不复杂，甚至可以说非常简单，各位说对吗。不过其中有一点值得LZ一提，就是为什么非要停止程序的运行呢？这个其实也不难理解，LZ举个最简单的例子，假设我们的程序与GC线程是一起运行的，各位试想这样一种场景。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们刚标记完图中最右边的那个对象，暂且记为A，结果此时在程序当中又new了一个新对象B，且A对象可以到达B对象，但是由于此时A对象已经标记结束，B对象此时的标记位依然是0，因为它错过了标记阶段，因此当接下来轮到清除阶段的时候，新对象B将会被苦逼的清除掉。如此一来，不难想象结果，GC线程将会导致程序无法正常工作。上面的结果当然令人无法接受，我们刚new了一个对象，结果经过一次GC，忽然变成null了，这还怎么玩？

**标记/清除算法缺点**

1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，**需要停止应用程序**，这会导致用户体验非常差劲，尤其对于交互式的应用程序来说简直是无法接受。试想一下，如果你玩一个网站，这个网站一个小时就挂五分钟，你还玩吗？

2、第二点主要的缺点，则是这种方式**清理出来的空闲内存是不连续的**，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。



----------
欢迎关注个人微信公众号：<br/>
![](/images/weixin.jpg)