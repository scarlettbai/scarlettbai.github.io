---
layout: post
title: Java生成随机不重复推广码邀请码
description: "Java生成随机不重复推广码邀请码."
tags: [Java,加密/解密]
image:
  background: triangular.png
---
最近接到一个需求，要批量生成推广码，首先我们知道推广码的特效有如下两点：<br/>
1：不可重复<br/>
2：不可以被推测出<br/>

**关于这两点，我们的思路大体分为如下几类：**<br/>
1:每次生成一个随机码后**查数据库是否有相同**的，有则重新生成(每次都要访问数据库，导致效率极低，不推荐)<br/>

2:依据**数据库的主键作为唯一键**，进行打乱或插入操作，如主键为8000001，取出后生成3位(据需求增减)随机数或字母，插入主键值中，构成如8000E0V0S1D这种串，可保证推广码不重复及不可推测出(这种方式也需要连接数据库取主键，当然可以一次性预生成所需数目的主键，然后生成对应推广码后更新进数据库，效率会高一些)<br/>

3:利用**算法**来保证值唯一，如UUID等，本篇重点介绍此种方式(不需连接数据库，算法选择合适则效率很高)


**具体实现**<br/>
上面说了，本文重点讨论利用算法实现不重复性，首先我们会想到最简单的方式：**UUID**,我们来看下具体效果：<br/>
![](/postimages/uuid20160329205158.png)<br/>

图中可以看出，**UUID生成的随机串去掉-后长度为32位**，虽然可以保证几乎绝对不会出现重复情况且支持多线程并发也不会重复，但是**长度太长**，不太实用。

既然UUID被淘汰了，那么接下来我们来看下我们最常接触的**SHA**算法：<br/>
![](/postimages/SHA20160329210326.png)<br/>

从图中可以看出，SHA算法生成的串也明显**太长，淘汰**。

接下来我想到了对称加密算法中的**RC4**，他可以保证密文长度和原字符串长度一样，关于RC4算法本篇不多描述，大家有兴趣可以上google百度一下，算法网上也有一大堆，大家可以随便下一个就好，此处**密文选为自增的数字，秘钥写死**，接下来我们看一下效果：<br/>
![](/postimages/RELRC420160330101624.png)<br/>

图中可以看出，生成的码**不在字母及数字范围内**，不可能拿这些码给用户作为推广码，那么最简单的一个方式是，将这个码转换为16进制，效果如下：<br/>
![](/postimages/RC4WHITE20160330102021.png)<br/>

大家可以看到，此时**密文都成了我们所熟知的字母和数字，但是长度变为了原字符长度的2倍**，不过依旧算可以接受，但是看加密后的密文全都是连续性的，不满足推广码第二点的可推测，而且由于私钥全都一样容易被破解，此处我们不需求解密，所以可以直接把**私钥换成UUID**，来看下效果：<br/>
![](/postimages/uuidRC420160330092447.png)<br/>

可以看到，此处生成的密文不再可以推测出，满足了我们的需求，那么对于是否会重复，我们再来做个测试，此处选用的**需加密字符串长度为7位**：<br/>
![](/postimages/uuidRC4ALL20160330092950.png)<br/>

从图中可以看出，**字符串长度为7位时，生成了九百多万个密文，都没有重复的**，基本可以满足绝大部分情况，更多的我也没有进行测试，大家有兴趣可以测试下生成多少位时会出现重复。此种做法的好处是，**原字符串长度越长，生成的不会重复的密文量级则会更大**，大家可以按需调节。

不过这种方式的唯一不足在于，**生成的密文长度是偶数的**，如果大家需要确定的奇数长度密文，可以把**RC4加密结果用别的方式转换**为我们常用的字母和数字，楼主本处是没有特殊需求，所以直接采用了转换16进制这种快捷偷懒的方式。

----------
欢迎关注个人微信公众号：<br/>
![](/images/weixin.jpg)